[{"title":"Ubuntu安装golang","date":"2018-01-04T10:37:30.000Z","path":"2018/01/04/Ubuntu安装golang/","text":"1.首先，去官网下载对应版本的压缩包：https://golang.org/dl/2.解压1sudo tar -zxvf go1.11.1.linux-amd64.tar.gz 3.将解压后的文件夹go移动到/usr/local1sudo mv go /usr/local 4.设置环境变量12345678vim ~/.bashrc //尾部输入,path目录可以自己定义export GOROOT=/usr/local/goexport GOPATH=$HOME/goprojectsexport GOBIN=$GOPATH/binexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin//使修改生效source ~/.bashrc 5.验证12345678simon@virtual-machine:~$ go env...GOHOSTARCH=&quot;amd64&quot;GOHOSTOS=&quot;linux&quot;GOOS=&quot;linux&quot;GOPATH=&quot;/home/simon/goprojects&quot;...GOROOT=&quot;/usr/local/go&quot; 6.代码测试前面我的go脚本存放在~/goprojects下面，按照go的workspace设计，在下面依次存放src, pkg, bin目录，在src中，存放不同的项目文件，每个项目对应一个子文件夹，参见下面的目录结构,并在src目录下新建一个hello文件夹，放入hello.go文件，内容如下目录结构：12345678goprojects├── bin│ └── hello├── pkg└── src └── hello ├── hello └── hello.go 测试代码1234567package mainimport \"fmt\"func main() &#123; fmt.Println(\"Hello World\")&#125; 在hello.go的当前目录下面，采用几种方法运行1.在当前目录下面会生成hello123go build hello.go//执行./hello 2.将hello.go生成的文件存放在统一的bin文件下面123go install hello.go//执行./hello 3.检查程序是否可以编译通过，直接显示结果，并不会生成可执行文件1go run hello.go","tags":[{"name":"go","slug":"go","permalink":"http://yoursite.com/tags/go/"}]},{"title":"Ubuntu上的防火墙iptables简单使用","date":"2018-01-04T10:37:30.000Z","path":"2018/01/04/Ubuntu上的防火墙iptables/","text":"1.安装配置Ubuntu默认安装是没有开启任何防火墙的，为了服务器的安全，建议大家安装启用防火墙设置，这里推荐使用iptables防火墙.如果mysql启本地使用,可以不用打开3306端口. 12root@virtual-machine:~# whereis iptables //查看系统是否安装防火墙可以看到:iptables: /sbin/iptables /usr/share/iptables /usr/share/man/man8/iptables.8.gz //表示已经安装iptables 如果没有安装，请运行如下命令：1root@virtual-machine:~# apt-get install iptables 2.查看iptables配置1）按列表查看访问规则123456789root@virtual-machine:~# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination Chain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination 2）按INPUT，OUTPUT，FORWARD三个类查看访问规则12345root@virtual-machine:~# iptables -S-P INPUT ACCEPT-P FORWARD ACCEPT-P OUTPUT ACCEPT-A INPUT -p tcp -m tcp --dport 80 -j DROP 3.设置iptables的缺省规则未设置其他的规则时的INPUT/OUTPUT/FORWARD数据包设置为ACCEPT是允许接收，设置为DROP是拒绝接收。 INPUT是从外头进入本机的数据包 OUTPUT是从本机出去的数据包 FORWARD是经过本机的数据包，用在路由器等中转设备上，对于终端设备，不常用。 123iptables -P INPUT ACCEPT/DROPiptables -P OUTPUT ACCEPT/DROPiptables -P FORWARD ACCEPT/DROP 缺省规则是给予设置有很大的方便，比如说，你要设置只允许别人访问本机的http服务，那么可以设置INPUT和OUTPUT缺省为DROP，拒绝接收，设置一条从外部通过http访问的规则为ACCEPT即可。反过来，如果你要设置除了telnet服务，其他任何服务都允许访问，那么可以设置INPUT和OUTPUT缺省为ACCEPT，设置一条从外部通过telnet访问的规则为DROP即可。 4.添加iptables的规则1）添加INPUT链的规则：1iptables -A INPUT -p tcp --dport 23 -j DROP -A代表append添加规则，后面带INPUT代表这种数据包，-p代表使用的协议为tcp，–dport代表端口为23，-j代表使用DROP还是ACCEPT，DROP为拒绝意思为拒绝tcp协议端口为23的数据包进入，而默认时telnet使用tcp23端口，所以此时其他机器telnet访问本机时被拒绝 2）添加OUTPUT链的规则：1iptables -A OUTPUT -p tcp --dport 80 -j DROP -A代表append添加规则，后面带OUTPUT代表这种数据包，-p代表使用的协议为tcp，–dport代表端口为80，-j代表使用DROP还是ACCEPT，DROP为拒绝意思为拒绝tcp协议端口为80的数据包出去，而通常http使用的端口为80，所以此时本机访问http服务80时被拒绝。 3）FORWARD和前两种方式一样，只不过是经过的数据包。 4）自定义链的规则 5.存储与恢复iptables的规则因为上面设置规则后，重启则规则失效，所以要将其存储起来。使用命令 iptables-save &gt;存储文件名 1root@virtual-machine:~# iptables-save &gt;/etc/iptables.rules 存入文件iptables.rules中了，当电脑重启时再使用命令iptables-restore &lt;存储文件名 创建文件，添加以下内容，使防火墙开机启动12345678# vim /etc/network/if-pre-up.d/iptables#!/bin/bashiptables-restore &lt; /etc/iptables.rules# chmod +x /etc/network/if-pre-up.d/iptables #添加执行权限# iptables -L -n查看规则是否生效 6.清除iptables的规则1）清除预设表中的所有规则链的规则 1iptables -F 运行此后，所有的规则链（包括自定义链和三种链）都被清空 2）清除预设表filter中使用的自定义链（即除了INPUT/OUTPUT/FORWARD链）中的规则1iptables -X 3）清除单条规则和前面第三节的添加规则相同，这里把-A添加改为-D即可删除已经设置了的规则1iptables -D OUTPUT -p tcp --dport 80 -j DROP","tags":[{"name":"iptables","slug":"iptables","permalink":"http://yoursite.com/tags/iptables/"}]},{"title":"PHP使用CURL发送请求","date":"2018-01-03T09:17:46.000Z","path":"2018/01/03/PHP使用CURL发送请求/","text":"PHP使用CURL详解CURL是一个非常强大的开源库，支持很多协议，包括HTTP、FTP、TELNET等，我们使用它来发送HTTP请求。它给我们带来的好处是可以通过灵活的选项设置不同的HTTP协议参数，并且支持HTTPS。CURL可以根据URL前缀是“HTTP” 还是“HTTPS”自动选择是否加密发送内容。 使用CURL发送请求的基本流程使用CURL的PHP扩展完成一个HTTP请求的发送一般有以下几个步骤： 初始化连接句柄：curl_init() 设置CURL选项：curl_setopt() 执行并获取结果：curl_exec() 释放URL连接句柄：curl_close() 下面的程序片段是使用CURL发送HTTP的典型过程：12345678910111213// 1. 初始化$ch = curl_init();// 2. 设置选项，包括URLcurl_setopt($ch, CURLOPT_URL, \"http://www.baidu.com\");curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);curl_setopt($ch, CURLOPT_HEADER, 0);// 3. 执行并获取HTML文档内容$output = curl_exec($ch);if ($output === FALSE) &#123; echo \"CURL Error:\" . curl_error($ch);&#125;// 4. 释放curl句柄curl_close($ch); 获取CURL请求的输出信息在curl_exec()函数执行之后，可以使用curl_getinfo()函数获取CURL请求输出的相关信息，示例代码如下：123$output = curl_exec($ch);$info = curl_getinfo($ch);echo ' 获取 '.$info['url'].'耗时'.$info['total_time'].'秒'; 上述代码中curl_getinfo返回的是一个关联数组，包含以下数据： 1234567891011121314151617181920url:网络地址。content_type:内容编码。http_code:HTTP状态码。header_size:header的大小。request_size:请求的大小。filetime:文件创建的时间。ssl_verify_result:SSL验证结果。redirect_count:跳转计数。total_time:总耗时。namelookup_time:DNS查询耗时。connect_time:等待连接耗时。pretransfer_time:传输前准备耗时。size_uplpad:上传数据的大小。size_download:下载数据的大小。speed_download:下载速度。speed_upload:上传速度。download_content_length:下载内容的长度。upload_content_length:上传内容的长度。starttransfer_time:开始传输的时间表。redirect_time:重定向耗时。 使用CURL发送GET请求如何使用CURL来发送GET请求，发送GET请求的关键是拼装格式正确的URL。请求地址和GET数据由一个“?”分割,然后GET变量的名称和值用“=”分隔，各个GET名称和值由“&amp;”连接。PHP为我们提供了一个函数专门用来拼装GET请求和数据部分—http_build_query,该函数接受一个关联数组，返回由该关联数据描述的GET请求字符串。使用这个函数，结合CURL发送HTTP请求的一般流程，我们封闭了一个发送GET请求的函数—doCurlGetRequest,具体代码如下： 123456789101112131415/**@desc 封闭curl的调用接口，get的请求方式。*/function doCurlGetRequest($url, $data, $timeout = 5)&#123; if ($url == \"\" || $timeout &lt;= 0) &#123; return false; &#125; $url = $url . '?' . http_build_query($data); $con = curl_init((string)$url); curl_setopt($con, CURLOPT_HEADER, false); curl_setopt($con, CURLOPT_RETURNTRANSFER, true); curl_setopt($con, CURLOPT_TIMEOUT, (int)$timeout); return curl_exec($con);&#125; 使用CURL发送POST请求可以使用CURL提供的选项CURLOPT_POSTFIELDS，设置该选项为POST字符串数据就可以把请求放在正文中。同样我们实现了一个发送POST请求的函数—doCurlPostRequest，代码如下：123456789101112131415161718/** * @desc 封装 curl 的调用接口，post的请求方式 */function doCurlPostRequest($url, $requestString, $timeout = 5)&#123; if ($url == '' || $requestString == '' || $timeout &lt;= 0) &#123; return false; &#125; $ch = curl_init((string)$url); //设置url curl_setopt($ch, CURLOPT_HEADER, false); //设置头信息 curl_setopt($ch, CURLOPT_POST, true); //设置发送方式为post请求 curl_setopt($ch, CURLOPT_POSTFIELDS, $requestString); //设置post的数据 curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); //设置curl_exec获取的信息的返回方式 curl_setopt($ch, CURLOPT_TIMEOUT, (int)$timeout); //设置超时时间 curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); //禁止 cURL 验证对等证书（peer’s certificate） curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); //表示不检查证书 return curl_exec($ch);&#125; CURL设置Authorization头信息&amp;发送接收JSON数据相关代码：123456789101112131415$url = \"http://test.dev/check.php\";$data = array('username' =&gt; 'zhangsan', 'age' =&gt; 30);$opt_data = json_encode($data);$header = array();$header[] = 'Authorization:'.'test';$header[] = 'Accept:application/json';$header[] = 'Content-Type:application/json;charset=utf-8';$curl = curl_init(); //初始化curl_setopt($curl,CURLOPT_URL,$url); //设置urlcurl_setopt($curl,CURLOPT_HTTPHEADER,$header);curl_setopt($curl,CURLOPT_POSTFIELDS,$opt_data);$result = curl_exec($curl);curl_close($curl); 在接收端，发现使用POST是接收不到数据的，当然_REQUEST也是一样，那么我们传的JSON数据哪里去了呢？怎么才能接收到传递的JSON数据？123$str = file_get_contents(\"php://input\");//或者$str = $GLOBALS['HTTP_RAW_POST_DATA']; 为什么会出现POST获取不到传送的数据的问题呢？因为$_POST只能接收文档类型为“Content-Type: application/x-www-form-urlencoded”格式提交的数据。HTTP_RAW_POST_DATA是用来接收原始的POST数据的，只有在碰到未识别的MIME类型时才会被填充，所以使用它可以获取到上面代码POST的json数据。如果使用的是php7，$GLOBALS[&#39;HTTP_RAW_POST_DATA&#39;]的值为空，原因是php7已移除这个全局变量。所以直接用file_get_contents(&quot;php://input&quot;)接收最好。","tags":[{"name":"curl","slug":"curl","permalink":"http://yoursite.com/tags/curl/"}]},{"title":"Hello World","date":"2018-01-03T08:17:46.000Z","path":"2018/01/03/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info:111 Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]